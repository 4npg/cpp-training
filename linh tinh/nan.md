# 2. Prim 算法

**算法思路**：Prim 算法的思路与 Dijkstra 算法（在图中寻找最短路径）的思路非常相似。  
如果说 Kruskal 算法是通过逐步将**边**纳入图中来构建最小生成树，那么 Prim 算法则是按照以下标准逐步将**顶点**纳入图中：下一个要纳入的顶点必须是尚未被纳入，并且与已纳入图中的顶点距离最近。

算法包含以下步骤：

- 初始化集合 \( S \) 为当前生成树，开始时 \( S \) 中没有任何顶点。
- 初始化数组 \( D \)，其中 \( D_i \) 表示顶点 \( i \) 到已纳入集合 \( S \) 中任意顶点的最短距离，初始时 \( D[i] = +\infty \)。
- 重复以下操作 \( n \) 次（\( n \) 为图的顶点数）：
  - 找到不属于 \( S \) 且 \( D_u \) 最小的顶点 \( u \)，将 \( u \) 加入集合 \( S \)。
  - 检查所有与 \( u \) 相邻的顶点 \( v \)，更新 \( D_v = \min(D_v, w_{u,v}) \)，其中 \( w_{u,v} \) 是边 \( u-v \) 的权重。如果 \( D_v \) 根据 \( w_{u,v} \) 更新，则标记 \( \text{trace}_v = u \)。
  - 将边 \( u - \text{trace}[u] \) 加入最小生成树的边集中。

尽管不是强制要求，但你可以在此处阅读 Wikipedia 上关于算法正确性证明的内容 \( \square \)。

完成上述 \( n \) 个步骤后，我们将得到图的最小生成树，其中包含 \( n \) 个顶点和 \( n-1 \) 条边。

示例：使用 Prim 算法求解最小生成树问题的步骤：